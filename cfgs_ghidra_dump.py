import os
import sys
import time
import shutil
import logging
import pyghidra
import networkx as nx
from networkx.drawing.nx_pydot import write_dot 

# How does this script work briefly:
#  * Takes a PE executable 
# -> Builds a ICFG using Ghidra 

#Function that prints some stats for the graph
def stats_graph(G):
	
	n = G.order()
	m = G.size()
	cwcc = sum(1 for _ in nx.weakly_connected_components(G))
	cscc = sum(1 for _ in nx.strongly_connected_components(G)) 
	logger.info("Order: " + str(n))
	logger.info("Size: " + str(m))
	logger.info("Nr of WCC:" + str(cwcc))
	logger.info("Nr of SCC:" + str(cscc))

	return (n,m,cwcc,cscc)

#Function that returns the ICFG, generated by Ghidra, as a networkx's DiGraph object
#Takes as argument a file's path
def gen_cfgs(fpath):
	
	cfgs = []
	fname = fpath.split(".")[0].split('/')[-1]
	
	sta = time.time()
	with pyghidra.open_program(fpath,project_name=f"{fname}_ghidra") as flat_api: #Analyze the binary file
		
		eta = time.time()
		logger.info(f"Binary Analized in {eta-sta:.2f}s")
		
		program = flat_api.getCurrentProgram()
		func_manager = program.getFunctionManager() # Get the Function Manager 	
		programListing = program.getListing() #Get the Listing
		monitor = ConsoleTaskMonitor() #Spawn monitor

		#Use Basic Block to exclude CALL instructions as Flow instructions in the CFG
		bm = BasicBlockModel(program,includeExternals=False)
	
		#Build a symbol dictionary. We use this to translate external
		#CALL functions from their address to their function name.
		symbols = program.symbolTable.getExternalSymbols()
		external_pointers = dict()

		# Iterate through symbols, build the dictionary.
		# Key: External Linkage Address : Symbol
		for s in symbols:
			external_pointers[str(getExternalLinkageAddresses(program, s.getAddress())[0])] = str(s)

		functions = func_manager.getFunctionsNoStubs(True)
		stb = time.time()

		for f in functions:

			cfg = nx.DiGraph()
			func_addr = f.getBody()
			codeBlockIterator = bm.getCodeBlocksContaining(func_addr,monitor)

			#Parse all the blocks in the function
			while codeBlockIterator.hasNext(): 
				block = codeBlockIterator.next() 
				addr = str(block.getFirstStartAddress()) #Get start address
				code = "" #We save Code Instructions here

				#Extract the block's code
				codeUnit = programListing.getCodeUnits(block,True) #Get the code from the block

				# Parse each instruction in the block
				while codeUnit.hasNext(): 
					inst = codeUnit.next()

					# Process external CALL instructions
					if inst.getMnemonicString() == 'CALL':
						call_addr = str(inst.getOpObjects(0)[0]) # Get address argument
						if call_addr in external_pointers.keys(): # If the address is external
							inst = "CALL " + external_pointers[call_addr] # Substitute with the func. name
					code += str(inst)
					if codeUnit.hasNext(): code+='\n'

				cfg.add_node('"'+addr+'"',Code=code) # Add node to the ICFG (Note: We add quotes for .dot files)

				#We get the edges for this node by getting the block's destinations
				dest = bm.getDestinations(block,monitor) 

				# We generate the block's edges by its destinations/successors
				while dest.hasNext():
					d = dest.next()
					daddr = str(d.getDestinationAddress()) # Get address for destination
					flow = str(d.getFlowType()) # Get Flow Type

					if not 'CALL' in flow:
						cfg.add_edge('"'+addr+'"','"'+daddr+'"' ,EdgeType=flow) #Add it to the ICFG
			
				
			#Add stats to the CFG
			n,m,cwcc,cscc = stats_graph(cfg)
			funcName = f.getName()
			cfg.graph['graph']={'order':n,'size':m,'name':funcName}

			logger.info(f"CFG for {f.getName()} built..")	
			cfgs.append(cfg)

		etb = time.time()
		logger.info(f"Graphs proccesed in {etb-stb:.2f}s")
		return cfgs

if __name__ == '__main__':


	os.environ['GHIDRA_INSTALL_DIR'] = '/opt/ghidra' #hardcoded default path to ghidra installation folder
	if len(sys.argv) > 1:
		tofile = sys.argv[1]

		if os.path.exists(tofile):
			fname = tofile.split(".")[0].split('/')[-1]
			logger = logging.getLogger(__name__) # TO DO: this should be improved in the future to keep the function name
			logging.basicConfig(filename=f"{fname}.log", encoding='utf-8', level=logging.DEBUG)
			logging.getLogger().addHandler(logging.StreamHandler(sys.stdout)) #Log to STDOUT too
			
			logger.info("Initialzing Headless Analyzer..")
			pyghidra.start() #Initialize the headless analyzer, make sure the env. variable GHIDRA_INSTALL_DIR is set accordingly.

			from ghidra.app.util.bin import ByteProvider
			from ghidra.util.task import ConsoleTaskMonitor
			from ghidra.app.util.bin import MemoryByteProvider
			from ghidra.program.model.block import BasicBlockModel
			from ghidra.app.util.bin.format.pe import OptionalHeader
			from ghidra.app.util.bin.format.pe import PortableExecutable
			from ghidra.app.nav.NavigationUtils import getExternalLinkageAddresses
		
			os.mkdir(f"{fname}_cfgs")
			os.chdir(f"{fname}_cfgs")
			logger.info(f"Building graphs for {fname}..")
	
			stg = time.time()
			Gs = gen_cfgs(tofile)
			etg = time.time()
			logger.info(f"Graph built in {etg-stg:.2f}s")

			for g in Gs:
				func_name = g.graph['graph']['name']
				nx.nx_pydot.write_dot(g,f"{fname}_{func_name}.dot") # Dump the graphs to a dot file
	else:
		print("Missing path to binary..\n Use: python icfg_dump.py <PATH>)")
