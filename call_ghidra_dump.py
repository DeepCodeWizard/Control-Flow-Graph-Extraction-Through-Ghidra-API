import os
import sys
import time
import shutil
import logging
import pyghidra
import networkx as nx
from networkx.drawing.nx_pydot import write_dot 

# How does this script work briefly:
#  * Takes a PE executable 
# -> Builds a ICFG using Ghidra 

#Function that prints some stats for the graph
def stats_graph(G):
	
	n = G.order()
	m = G.size()
	cwcc = sum(1 for _ in nx.weakly_connected_components(G))
	cscc = sum(1 for _ in nx.strongly_connected_components(G)) 
	logger.info("Order: " + str(n))
	logger.info("Size: " + str(m))
	logger.info("Nr of WCC:" + str(cwcc))
	logger.info("Nr of SCC:" + str(cscc))

	return (n,m,cwcc,cscc)

#Extract the entry address from the Portable Executable using Ghidra API (PE File)
#Inspiration for this function:
#https://gitlab.com/saruman9/ghidra_scripts/-/blob/master/GetEntryPoints.java
def getEntryPointAddress(ghidra_program_object):
		logger.info("Getting Entry Address")
		byteProvider = MemoryByteProvider(ghidra_program_object.getMemory(),ghidra_program_object.getImageBase())
		pe = PortableExecutable(byteProvider, PortableExecutable.SectionLayout.MEMORY)
		optHeader = pe.getNTHeader().getOptionalHeader()
		entry_address = hex(optHeader.getAddressOfEntryPoint() + ghidra_program_object.getImageBase().getOffset()).replace('0x','')
		entry_address = '"'+entry_address.rjust(8,'0')+'"' #Pad from right with 0s
		logger.info("Entry at {}".format(entry_address))
		return entry_address

#Function that returns the ICFG, generated by Ghidra, as a networkx's DiGraph object
#Takes as argument a file's path
def gen_calls(fpath):
	callgraph = nx.DiGraph()
	fname = fpath.split(".")[0].split('/')[-1]
	sta = time.time()
	with pyghidra.open_program(fpath,project_name=f"{fname}_ghidra") as flat_api: #Analyze the binary file
		eta = time.time()
		logger.info(f"Binary analized in {eta-sta:.2f}s")
		
		program = flat_api.getCurrentProgram()
		monitor = ConsoleTaskMonitor() #Spawn monitor
		fman = program.getFunctionManager() # Get Function Manager
		funcs = fman.getFunctions(True) #Get all functions

		stb = time.time()
	
		#For each internal function
		for f in funcs:
			called = f.getCalledFunctions(monitor) # Get the functions it calls
			# For each called function add an edge from the function to the called functions
			for c in called: 
				callgraph.add_edge('"'+f.getName()+'"','"'+c.getName()+'"')

		etb = time.time()
		logger.info(f"Call Graph Nodes processed in {etb-stb:.2f}s")
		try:
			entry_address = getEntryPointAddress(program)
			pass
		except Exception:
			entry_address = 'Uncomputed'
			pass

		#Add stats to the ICFG
		#cwcc -  Cardinal Weak Connected Components
		#cscc - Cardinal Strong Connected Components
		n,m,cwcc,cscc = stats_graph(callgraph)

		callgraph.graph['graph']={'order':n,'size':m,'cwcc':cwcc,'cscc':cscc,'entry':entry_address}

		logger.info("Call Graph Built..")
		return callgraph

if __name__ == '__main__':


	os.environ['GHIDRA_INSTALL_DIR'] = '/opt/ghidra' #hardcoded default path to ghidra installation folder
	if len(sys.argv) > 1:
		tofile = sys.argv[1]

		if os.path.exists(tofile):
			fname = tofile.split(".")[0].split('/')[-1]
			logger = logging.getLogger(__name__) # TO DO: this should be improved in the future to keep the function name
			logging.basicConfig(filename=f"{fname}.log", encoding='utf-8', level=logging.DEBUG)
			logging.getLogger().addHandler(logging.StreamHandler(sys.stdout)) #Log to STDOUT too
			
			logger.info("Initialzing Headless Analyzer..")
			pyghidra.start() #Initialize the headless analyzer, make sure the env. variable GHIDRA_INSTALL_DIR is set accordingly.

			from ghidra.app.util.bin import ByteProvider
			from ghidra.util.task import ConsoleTaskMonitor
			from ghidra.app.util.bin import MemoryByteProvider
			from ghidra.program.model.block import SimpleBlockModel
			from ghidra.app.util.bin.format.pe import OptionalHeader
			from ghidra.app.util.bin.format.pe import PortableExecutable
			from ghidra.app.nav.NavigationUtils import getExternalLinkageAddresses
		
			logger.info(f"Building Call Graph for {fname}..")
			stg = time.time()
			G = gen_calls(tofile)
			etg = time.time()
			logger.info(f"Call Graph built in {etg-stg:.2f}s")
			nx.nx_pydot.write_dot(G,f"{fname}_calls.dot") # Dump the graph to a dot file
	else:
		print("Missing path to binary..\n Use: python callgraph_dump.py <PATH>)")
